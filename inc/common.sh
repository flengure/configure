#!/bin/sh

# common.sh
#
# Description:
# This script provides a collection of general utility functions intended for
# use in other scripts. The functions included are designed to perform various
# common tasks such as checking execution contexts, copying content to files,
# running scripts, and manipulating lists.
#
# Functions:
# - is_direct_execution: Checks if the script is executed directly or sourced from another script.
# - copy_content: Copies specified content into a file, optionally using `sudo` for elevated permissions.
# - run_script: Executes a script located in the same directory as the currently executing script.
# - contains_element: Checks if an element is present in a space or newline-separated list.
# - remove_element: Removes all occurrences of a specified element from a space- and newline-separated list.
# - list_functions: Lists the names of functions in a given script file.
#
# Usage:
# Source this script in your other scripts to use its functions:
#   . /path/to/common.sh
#
# POSIX Compliance:
# This script is designed to be POSIX-compliant to ensure portability across
# different Unix-like operating systems. Please adhere to POSIX standards when
# modifying or extending this script.
#
# Author:
# Tonye George (2024)
#

# Get the script path, directory and name
SCRIPT_PATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
SCRIPT_NAME="$(basename "$SCRIPT_PATH")"

# capture_stderr - Captures stderr output of a command into a variable
#
# This function executes a command and captures any error messages (stderr)
# generated by the command into a specified variable. The standard output (stdout)
# of the command is displayed normally. The function uses a temporary file to
# store stderr, which is then read into the variable. The temporary file is cleaned
# up after use.
#
# Usage:
#   capture_stderr <stderr_var> <command> [args...]
#
# Parameters:
#   stderr_var - The name of the variable where stderr output will be stored.
#   command - The command to execute. Any additional arguments will be passed to the command.
#
# Example:
#   capture_stderr error_message ls /nonexistent/file
#   echo "Captured stderr: $error_message"

capture_stderr() {
    local stderr_var="$1"
    shift

    # Create a temporary file to capture stderr
    local tmpfile
    tmpfile=$(mktemp)

    # Execute the command, redirect stderr to the temporary file
    "$@" 2> "$tmpfile"

    # Read the content of the temporary file into the variable
    printf -v "$stderr_var" '%s' "$(cat "$tmpfile")"

    # Cleanup: Remove the temporary file
    rm -f "$tmpfile"
}


source_base() {
    file="$1"

    # Attempt to locate and source the file from the following base paths:

    # 1. Directory of the currently executed script
    #    - $(dirname "$(realpath "$0")")
    #    - This path is used when the script is executed directly.
    #    - It resolves the absolute path of the script being run and uses its directory.

    # 2. Directory of the script being sourced
    #    - $(dirname "$(realpath "${BASH_SOURCE[0]}")")
    #    - This path is used when the script is sourced from another script.
    #    - It resolves the absolute path of the file where the function is defined, ensuring correct path resolution.

    for base_path in \
        "$(dirname "$(realpath "$0")")" \
        "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"; do
        file_path="$base_path/$file"
        if [[ -f "$file_path" ]]; then
            source "$file_path"
            return 0
        fi
    done

    # If not found, print an error message
    printf "file not found: %s\n" "$file"
    return 1
}


# is_direct_execution
#
# Checks if the current script is executed directly by the user or invoked from
# another script. This function determines if the parent process is a shell (bash
# or sh), which would indicate that the script is running in a direct execution context.
#
# Returns:
#   0 if the script is executed directly.
#   1 if the script is executed from another script.
#
# Usage:
#   if is_direct_execution; then
#       echo "Script is running directly"
#   else
#       echo "Script is running from another script"
#   fi

is_direct_execution() {
	# Get the parent process ID (PPID)
	local parent_pid=$(ps -o ppid= -p $$)

	# Get the name of the parent process
	local parent_process=$(ps -p $parent_pid -o comm=)

	if [ "$parent_process" = "bash" ] || [ "$parent_process" = "sh" ]; then
		return 0
	else
		return 1
	fi
}

# copy_content
#
# Copies the specified content into a file, optionally using `sudo` for elevated permissions.
# The function checks if the file already exists and if its content is different from the 
# provided content. If either condition is true, it writes the content to the file.
#
# Parameters:
#   1. content (string): The content to be written into the file.
#   2. file (string): The file path where the content will be copied.
#   3. sudo_flag (string): If "sudo", the function uses `sudo` to write to the file. 
#                           Otherwise, it writes directly without `sudo`.
#
# Example:
#   copy_content "Hello, World!" "/path/to/file.txt" "sudo"
#
# Notes:
#   - If the `sudo_flag` is not provided or is anything other than "sudo", the function
#     writes directly to the file without elevated permissions.
#   - If the content is the same as what is already in the file, no action is performed.
#
# Usage:
#   copy_content "This is new content" "/path/to/file.txt" "sudo"

copy_content() {
    local content="$1"
    local file="$2"
    local sudo_flag="$3"

    if [ "$sudo_flag" == "sudo" ]; then
        local tee_cmd="sudo tee"
    else
        local tee_cmd="tee"
    fi

    if [ ! -f "$file" ] || [ "$(printf "%s" "$content")" != "$(cat "$file")" ]; then
        printf "Copying %s ... " "$file"
        printf "%s\n" "$content" | $tee_cmd "$file" > /dev/null
        printf "Done.\n"
    fi
}

# run_script
#
# Executes a script located in the same directory as the currently executing script.
# The script to be executed is specified by the first argument, and any additional
# arguments are passed to the script being executed.
#
# Parameters:
#   1. script_name (string): The name of the script to be executed, without the .sh extension.
#   2. [additional_args] (varargs): Additional arguments to be passed to the script being executed.
#
# The function constructs the path to the script based on the directory of the currently
# executing script, and checks if the specified script file exists before executing it.
#
# Example:
#   # In a script located in /path/to/scripts/
#   run_script "example" "arg1" "arg2"
#   # This will execute /path/to/scripts/example.sh with "arg1" and "arg2" as arguments.
#
# Notes:
#   - The function determines the directory of the currently running script using the BASH_SOURCE variable.
#   - If the specified script does not exist, an error message is printed and the function exits with status 1.

run_script() {
    # Determine the directory of the currently executing script
    local script_dir="$(dirname "$(realpath "$0")")"
    local script="${script_dir}/${1}.sh"
    shift

    if [ ! -f "$script" ]; then
        printf "File does not exist: %s\n" "$script"
        return 1
    fi

    "$script" "$@"
}

# contains_element - Check if an element is in a space or newline-separated list
#
# Usage:
#   contains_element <element> <list>
#
# Arguments:
#   element  - The item to check for in the list.
#   list     - A space or newline-separated list of items.
#
# Returns:
#   0 if the element is found in the list.
#   1 if the element is not found in the list.
#
contains_element() {
    local element="$1"
    local list="$2"

    awk -v element="$element" '
    BEGIN {
        RS = "[[:space:]\n]+"
        found = 0
    }
    $0 == element {
        found = 1
        exit
    }
    END {
        if (found) {
            print "true"
        } else {
            print "false"
        }
    }
    ' <<< "$list"
}


# remove_element
# This function removes all occurrences of a specified element from a space- and newline-separated list.
# It maintains the original spacing and line breaks while removing the specified element.
#
# Usage:
#   remove_element <element> <list>
#
# Arguments:
#   element - The element to be removed from the list.
#   list - The input list in which the element should be removed. The list can contain elements separated by spaces and newlines.

remove_element() {
    local element="$1"
    local list="$2"

    # Use awk to process the input list
    awk -v rm="$element" '
    BEGIN {
        # Initialize output field separator (OFS) to a space
        OFS = " "
    }
    {
        # Process each field in the record
        for (i = 1; i <= NF; i++) {
            if ($i == rm) {
                # If field matches the element to remove, set it to empty
                $i = ""
            }
        }
        # Print the record with fields removed, trimming extra spaces
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)  # Remove leading/trailing spaces
        gsub(/[[:space:]]+/, " ", $0)  # Replace multiple spaces with a single space
        if (length($0) > 0) {
            print
        }
    }
    ' <<< "$list"
}

list_functions() {
	awk '
		/^[a-zA-Z_][a-zA-Z0-9_]*\s*\(\s*\)\s*\{/ {
            gsub(/\s*\(\s*\)\s*(\{)?\s*$/, "", $1);
            print $1

	}' "$1"
}
